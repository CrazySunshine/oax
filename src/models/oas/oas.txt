import {Operation, Parameter, Path, Spec, Tag} from "swagger-schema-official";
import {OASUI, X, IMeta} from "./metas/index";



// interface SchemaExtended extends Schema {
//   _obj: any
// }

export class OAS {
  metas: IMeta[]
  resources: IResource[]
  operations: OperationExtended[]
  map: Map

  constructor(spec: Spec,
              url: string,
              defaultContentType: string = 'application/json',
              validatorUrl: string = 'http://online.swagger.io/validator') {
    OAS.fixInfo(spec, url, defaultContentType)
    this.map = {}
    this.metas = OASUI.getMeta(spec, url, validatorUrl)
    this.resources = OAS.getResources(spec, this.map)
    this.operations = OAS.getOperations(spec, this.resources, this.map)
  }

  static openAll(resources: IResource[], opened = true) {
    for (const r in resources) {
      resources[r]._opened = opened
    }
  }

  static getSearch(text: string) {
    if (!text) {
      return {}
    } else {
      const trimmed = text.toLowerCase().trim();
      const parts = trimmed.split(' ');
      const isMethod = HttpMethods[parts[0]];
      const method = (parts.length > 1) ? parts[0] : (isMethod ? parts[0] : '');
      const path = (parts.length > 1) ? parts[1] : (isMethod ? '' : parts[0]);

      return {method, path}
    }
  }

  static filterSearch(resources: IResource[], search: any) {
    for (let i = 0; i < resources.length; i++) {
      let r = resources[i]

      r._display = false
      r._opened = false

      for (let j = 0; j < r._operations.length; j++) {
        let o = r._operations[j];

        if ((search.method ? search.method === o._method : true) &&
          (search.path ? o._pathName.toLowerCase().indexOf(search.path) > -1 : true)) {
          o._display = true
          r._display = true
          r._opened = true
        } else {
          o._display = false
        }
      }
    }
  }



  static tagOperations(resources: IResource[]) {
    const operations = [];

    for (const r in resources) {
      const resource = resources[r]

      for (const o in  resource._operations) {
        const operation = resource._operations[o]
        operations.push(operation);
      }

      if (resources.length <= 8) {
        resource._opened = true;
      }
    }

    operations.sort(function (a, b) {
      return (a._pathName.toLowerCase().replace(/[^a-z]+/gi, '') + '-' + a._method)
        .localeCompare(b._pathName.toLowerCase().replace(/[^a-z]+/gi, '') + '-' + b._method);
    });

    return operations
  }

  static computeParameters(pathParameters: Parameter[], operation: OperationExtended): Parameter[] {
    let operationParameters: Parameter[] = operation.parameters || [];
    let parameters: Parameter[] = [].concat(operationParameters);

    for (let i = 0, l = pathParameters.length; i < l; i++) {
      let found: boolean = false;
      let pathParameter = pathParameters[i];

      for (let j = 0, k = operationParameters.length; j < k; j++) {
        let operationParameter = operationParameters[j]
        if (pathParameter.name === operationParameter.name && pathParameter.in === operationParameter.in) {
          // overridden parameter
          found = true;
          break;
        }
      }
      if (!found) {
        // add path parameter to operation ones
        parameters.push(pathParameter);
      }
    }
    return parameters;
  }

  static parseParameters(spec: Spec, operation: OperationExtended, pathParameters: Parameter[]/*, form, defaultContentType*/) {
    const parameters: Parameter[] = operation.parameters = OAS.computeParameters(pathParameters, operation);

    for (let i = 0, l = parameters.length; i < l; i++) {
      // TODO manage 'collectionFormat' (csv, multi etc.) ?
      // TODO manage constraints (pattern, min, max etc.) ?
      let param = parameters[i];
      // param.id = paramId;
      // param.type = model.getType(param);
      // param.description = trustHtml(param.description);

      // if (param.items && param.items.enum) {
      //   param.enum = param.items.enum;
      //   param.default = param.items.default;
      // }

      // param.subtype = param.enum ? 'enum' : param.type;

      // put param into form scope
      // form[operationId][param.name] = param.default || '';

      // if (param.schema) {
      // param.schema.display = 1; // display schema
      // param.schema.json = model.generateSampleJson(spec, param.schema);
      // param.schema.model = $sce.trustAsHtml(model.generateModel(spec, param.schema));
      // }

      if (param.in === 'body' || param.in === 'formData') {
        operation.consumes = operation.consumes || spec.consumes;
        // form[operationId].contentType = operation.consumes.length === 1 ? operation.consumes[0] : defaultContentType;
      }

      // paramId++;
    }
  }

  /*
   static parseResponses(swagger: Spec, operation: OperationExtended) {
   // var sampleJson;
   var sampleObj;

   operation.responses = operation.responses || {};
   operation._responses = [];

   for (const code in operation.responses) {
   let response = operation.responses[code]

   if (response.schema) {
   if (response.examples && response.examples[operation.produces[0]]) {
   // TODO: we prefer object(?)
   // sampleJson = angular.toJson(response.examples[operation.produces[0]], true);
   sampleObj = response.examples[operation.produces[0]];
   } else {
   // sampleJson = model.generateSampleJson(swagger, response.schema);
   // sampleObj = model.getSampleObj(swagger, response.schema);
   }

   // response.schema.json = sampleJson;
   (response.schema as SchemaExtended)._obj = sampleObj;

   if (response.schema.type === 'object' || response.schema.type === 'array') {
   response.display = 1; // display schema
   response.schema.model = $sce.trustAsHtml(model.generateModel(swagger, response.schema));
   } else if (response.schema.type === 'string') {
   delete response.schema;
   }

   if (code === '200' || code === '201') {
   operation.responseClass = response;
   operation.responseClass.display = 1;
   operation.responseClass.status = code;
   delete operation.responses[code];
   }
   }
   }
   }
   */
}
